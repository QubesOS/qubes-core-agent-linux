#!/usr/bin/env python3
# vim: fileencoding=utf-8
#
# The Qubes OS Project, https://www.qubes-os.org/
#
# Copyright (C) 2021
#                   David Hobach <tripleh@hackingthe.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

'''
Qrexec service for the notification-forwarder service to receive desktop
notifications.

Users may set `/qrexec/qubes-desktop-notify/allow-unicode` to `True` to
allow unicode text in notifications (default: replaced with question marks).
This may have security implications if the receiving desktop notification
server has issues with unicode input.
'''

import sys
import os
import io
import logging
from collections import namedtuple
from threading import Thread
import re
import pwd
import unicodedata
import dbus
import dbus.mainloop.glib
from gi.repository import GLib
import qubesdb

Notification = namedtuple("Notification", ("app_name", "notification_id", "app_icon",
                                           "summary", "body", "actions", "hints",
                                           "expire_timeout"))

class LimitingTextIOWrapper(io.TextIOWrapper):
    ''' A TextIOWrapper with a limit on chars to read per line. '''

    def __init__(self, *args, limit=-1, limit_marker="\n", **kwargs):
        self._limit = limit
        self._accept = True
        self.limit_marker = limit_marker
        super().__init__(*args, **kwargs)

    def readline(self, size=-1):
        read = super().readline(self._limit)
        if not read: #EOF
            return read

        if self._accept:
            self._accept = (read[-1] == "\n")
            return read
        self._accept = (read[-1] == "\n")
        return self.limit_marker

def get_logger():
    log = logging.getLogger("qubes.DesktopNotify")
    #NOTE: stderr is forwarded to the local log & the requesting VM (!!!)
    log.addHandler(logging.StreamHandler(sys.stderr))
    log.setLevel(logging.INFO)
    return log

#globals
LOG = get_logger()
IDS = dict() #calling notification ID --> our notification ID
BUS_NAME = "org.freedesktop.Notifications"
BUS_PATH = "/org/freedesktop/Notifications"
BUS = None
ALLOW_UNICODE = False

class ParseException(Exception):
    """ Thrown when untrusted content parsing failed and that content should be dropped/ignored. """
    def __init__(self, msg):
        LOG.warning(msg)
        iface = get_iface()
        iface.Notify("qubes.DesktopNotify", 0, "", "Notification dropped.", msg, [], {}, 5000,
                     signature="susssasa{sv}i")
        super().__init__()

def get_iface():
    global BUS
    if not BUS:
        BUS = dbus.SessionBus()
    proxy = BUS.get_object(BUS_NAME, BUS_PATH)
    return dbus.Interface(proxy, BUS_NAME)

def _notify(trusted_notification):
    iface = get_iface() #we shouldn't cache it as we'll run into issues otherwise (cf. notification-forwarder)

    return iface.Notify(
        trusted_notification.app_name,
        trusted_notification.notification_id,
        trusted_notification.app_icon,
        trusted_notification.summary,
        trusted_notification.body,
        trusted_notification.actions,
        trusted_notification.hints,
        trusted_notification.expire_timeout,
        signature="susssasa{sv}i"
    )

def notify(vm, trusted_notification):
    notification = trusted_notification

    #the ID is the caller ID --> fix it
    our_id = IDS.get(notification.notification_id, 0)

    #give the sending VM a dedicated field (summary) to hopefully avoid spoofing attacks (e.g. with backspaces)
    summary = vm
    if notification.body and notification.summary:
        body = " : ".join([notification.summary, notification.body])
    elif notification.body:
        body = notification.body
    else:
        body = notification.summary

    notification = Notification(
        app_name=notification.app_name,
        notification_id=our_id,
        app_icon=notification.app_icon,
        summary=summary,
        body=body,
        actions=notification.actions,
        hints=notification.hints,
        expire_timeout=notification.expire_timeout,
    )

    LOG.info(f"Notification from VM {vm}: {notification}")
    ret_id = _notify(notification)

    if trusted_notification.notification_id > 0:
        IDS[trusted_notification.notification_id] = ret_id

def close_notification(trusted_id):
    #the ID is the caller ID --> fix it
    try:
        our_id = IDS.pop(trusted_id)
    except KeyError:
        LOG.warning("Ignoring a close request for a notification that is not in our database.")
        return

    iface = get_iface()
    iface.CloseNotification(our_id, signature="u")

def regex_sanitize(vm, regex, untrusted_str, field):
    m = re.match(regex, untrusted_str)
    if m:
        return m.group(1)
    raise ParseException(f"Received unexpected message content in the field {field} from VM {vm}.")

def parse_notification_id(vm, untrusted):
    return int(regex_sanitize(vm, r"^([0-9]{1,6})$", untrusted, "notification_id"))

def parse_expire_timeout(vm, untrusted):
    return int(regex_sanitize(vm, r"^(\-?[0-9]{1,10})$", untrusted, "expire_timeout"))

def assert_printable(vm, untrusted, max_len):
    l = len(untrusted)
    if l >= max_len:
        raise ParseException(f"Received content of excessive length ({l} >= {max_len}) from VM {vm}.")

    allowed_chars = set(["\t", "\n", "\r"])
    ret = []
    for ch in untrusted:
        cat = unicodedata.category(ch)
        if cat[0] == "C" and ch not in allowed_chars:
            #https://www.unicode.org/reports/tr44/#GC_Values_Table
            ret += "?"
        else:
            ret += ch

    ret = "".join(ret)

    if not ALLOW_UNICODE:
        ret = ret.encode(encoding="ascii", errors="replace").decode("ascii")

    return ret

def parse_app_name(vm, untrusted):
    return assert_printable(vm, untrusted, 50)

def parse_app_icon(vm, untrusted):
    # The sending VM is supposed to either send a file:// URI or a well-known icon name.
    # We don't support raw binary icons at the moment (and it might not be wise to do so).

    #NOTE:
    # - modern Unix path names support everything except \0
    # - we enforce an absolute file path and only allow /usr/share/ icons to limit file probing attacks
    #   (the log/stderr is currently forwarded to the requester so he can see whether the file exists or not)
    m = re.match(r"^file://(/usr/share/[^\0]+\.(?:png|svg|gif))$", untrusted)
    if m:
        untrusted_path = m.group(1)

        if len(untrusted_path) > 200:
            raise ParseException(f"Received content with excessively long icon path from VM {vm}.")

        if "/tmp/" in untrusted_path:
            return ""

        real_path = os.path.realpath(untrusted_path)
        if untrusted_path != real_path:
            raise ParseException(f"The VM {vm} sent us a non-canonical file path for a notification icon. Attempted directory traversal attack?!")

        try:
            with open(untrusted_path):
                pass
        except IOError:
            return ""

        return untrusted

    #allowed: https://specifications.freedesktop.org/icon-naming-spec/latest/ar01s04.html
    m = re.match(r"^([a-z\-]{0,30})$", untrusted)
    if m:
        return m.group(1)

    return ""

def parse_summary(vm, untrusted):
    return assert_printable(vm, untrusted, 200)

def parse_body(vm, untrusted):
    return assert_printable(vm, untrusted, 1000)

def handle_untrusted_notification(vm, untrusted):
    if len(untrusted) >= 6 and len(untrusted) < 20:
        return Notification(
            notification_id=parse_notification_id(vm, untrusted[0]),
            expire_timeout=parse_expire_timeout(vm, untrusted[1]),
            app_name=parse_app_name(vm, untrusted[2]),
            app_icon=parse_app_icon(vm, untrusted[3]),
            summary=parse_summary(vm, untrusted[4]),
            body=parse_body(vm, "\n".join(untrusted[5:])),
            actions=[],
            hints={},
            )
    raise ParseException(f"Received message with too few or too many lines from VM {vm}.")

def handle_untrusted_message(vm, untrusted):
    try:
        if untrusted[0] == "close":
            if len(untrusted) == 2:
                trusted_id = parse_notification_id(vm, untrusted[1])
                close_notification(trusted_id)
                return
            raise ParseException(f"Received message of unexpected length from VM {vm}.")
        elif untrusted[0] == "notify":
            trusted_notification = handle_untrusted_notification(vm, untrusted[1:])
            notify(vm, trusted_notification)
            return
    except IndexError:
        raise ParseException(f"Received message with unexpected content from VM {vm}.")
    raise ParseException(f"Received message with unexpected command from VM {vm}.")

def handle_untrusted(vm):
    untrusted = []
    input_stream = LimitingTextIOWrapper(sys.stdin.buffer, limit=1000, limit_marker="\r")
    for untrusted_line in input_stream:
        #NOTE: sys.stdin is text-only in python by default (but might give us byte strings?)
        if not isinstance(untrusted_line, str):
            LOG.warning(f"Received non-string content from VM {vm}.")
            continue

        if untrusted_line == input_stream.limit_marker:
            continue

        untrusted_line = untrusted_line.rstrip("\n")

        if untrusted_line == "<qrexec>":
            untrusted = []
        elif untrusted_line == "</qrexec>":
            try:
                handle_untrusted_message(vm, untrusted)
            except ParseException:
                pass
            untrusted = []
        else:
            untrusted.append(untrusted_line)

class CloseWatcher(Thread):
    """ Watches dbus for close signals for notifications that we sent. """

    def __init__(self):
        dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
        self.bus = dbus.SessionBus()
        self.bus.add_signal_receiver(self.on_closed, signal_name="NotificationClosed", bus_name=BUS_NAME, path=BUS_PATH)
        super().__init__(daemon=True)

    def run(self):
        GLib.MainLoop().run()

    def on_closed(self, *args, **kwargs):
        LOG.debug("on_closed")
        try:
            our_id = args[0]
            reason = args[1]
        except IndexError:
            LOG.warning("Unexpected parameters passed to on_closed. Ignoring...")
            return

        for key, val in IDS.items():
            if val == our_id:
                IDS.pop(key, None)
                return

def set_env():
    if not os.environ.get("DISPLAY"):
        os.environ.setdefault("DISPLAY", ":0")
    if not os.environ.get("DBUS_SESSION_BUS_ADDRESS"):
        qdb = qubesdb.QubesDB()
        user = (qdb.read("/default-user") or b"user").decode()
        try:
            uid = pwd.getpwnam(user).pw_uid
        except KeyError:
            uid = 1000
        os.environ.setdefault("DBUS_SESSION_BUS_ADDRESS", f"unix:path=/run/user/{uid}/bus")

def main():
    global ALLOW_UNICODE
    set_env()

    vm = os.environ.get("QREXEC_REMOTE_DOMAIN")
    if not vm:
        LOG.error("Failed to identify the source VM.")
        sys.exit(4)

    qdb = qubesdb.QubesDB()
    unicode_str = qdb.read('/qrexec/qubes-desktop-notify/allow-unicode')
    ALLOW_UNICODE = (unicode_str == b"True")

    CloseWatcher().start()
    handle_untrusted(vm)

if __name__ == "__main__":
    main()
